<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.6201f5d795e66fbf05304d1348e60656f52a2bf20b7376034a0071179ec8a5881eb69432e4b8ae7f7c05a22afa7f9e33f628dca5b1d53f1dadacd7b3e6a86691.css integrity="sha512-YgH115Xmb78FME0TSOYGVvUqK/ILc3YDSgBxF57IpYgetpQy5Liuf3wFoir6f54z9ijcpbHVPx2trNez5qhmkQ==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Padding Oracle Attack a CBC - Introducción a la Seguridad Computacional</title><meta name=description content="DCC universidad de Chile"><link rel=canonical href=/auxiliares/anexos/padding-oracle/><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo_redondo.png"><meta name=twitter:title content="Padding Oracle Attack a CBC"><meta name=twitter:description content="Los ataques de tipo Padding Oracle se aprovechan de la estructura de mensajes cifrados en esquemas que utilizan padding para obtener el texto plano de un mensaje cifrado, realizando una cantidad de intentos considerablemente menor que los necesarios para obtenerlo mediante fuerza bruta y sin revelar la clave de cifrado.
El caso específico de padding oracle attack que veremos ahora aplica si se cumplen estas condiciones:
 Se usa criptografía simétrica, con cualquier tipo de cifrador de bloque y el modo de operación CBC."><meta name=twitter:site content="@dccuchile"><meta name=twitter:creator content="@dccuchile"><meta property="og:title" content="Padding Oracle Attack a CBC"><meta property="og:description" content="Los ataques de tipo Padding Oracle se aprovechan de la estructura de mensajes cifrados en esquemas que utilizan padding para obtener el texto plano de un mensaje cifrado, realizando una cantidad de intentos considerablemente menor que los necesarios para obtenerlo mediante fuerza bruta y sin revelar la clave de cifrado.
El caso específico de padding oracle attack que veremos ahora aplica si se cumplen estas condiciones:
 Se usa criptografía simétrica, con cualquier tipo de cifrador de bloque y el modo de operación CBC."><meta property="og:type" content="article"><meta property="og:url" content="/auxiliares/anexos/padding-oracle/"><meta property="og:image" content="/logo_redondo.png"><meta property="article:published_time" content="2020-03-24T10:00:00-03:00"><meta property="article:modified_time" content="2022-04-19T22:55:06-04:00"><meta property="og:site_name" content="Introducción a la Seguridad Computacional"><meta property="article:publisher" content="https://www.facebook.com/DCCUChile"><meta property="article:author" content="https://www.facebook.com/DCCUChile"><meta property="og:locale" content="es_CL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"\/"},{"@type":"ListItem","position":2,"name":"Auxiliaresanexospadding Oracle","item":"\/auxiliaresanexospadding-oracle\/"}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="auxiliares single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 mr-auto" href=/><img class=logo-light src=/images/banner.svg></img>
<img class=logo-dark src=/images/banner_dark.svg></img></a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/cc5327/apunte><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ml-2 sr-only">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=/acerca>Info</a></li><li class=nav-item><a class=nav-link href=/auxiliares/enunciados/auxiliar-1>Auxiliares</a></li><li class=nav-item><a class=nav-link href=/tareas/>Tareas</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Buscar Documentación..." aria-label="Buscar Documentación..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><div class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>anexos</h3><ul class=list-unstyled><li><a class="docs-link active" href=/auxiliares/anexos/padding-oracle/>Padding Oracle Attack a CBC</a></li><li><a class=docs-link href=/auxiliares/anexos/python-bytes/>Strings y Bytes en Python 3</a></li><li><a class=docs-link href=/auxiliares/anexos/gdb/>Uso básico de GDB</a></li></ul><h3>enunciados</h3><ul class=list-unstyled><li><a class=docs-link href=/auxiliares/enunciados/auxiliar-1/>Auxiliar 1</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>Contenidos</h3><nav id=TableOfContents><ul><li><a href=#el-modo-cbc>El modo CBC</a></li><li><a href=#padding-pkcs7>Padding PKCS#7</a></li><li><a href=#el-ataque>El ataque</a></li><li><a href=#el-algoritmo>El algoritmo</a><ul><li><a href=#obtener-el-último-byte-de-un-mensaje>Obtener el último byte de un mensaje</a></li><li><a href=#obtener-el-último-bloque-completo>Obtener el último bloque completo</a></li><li><a href=#obtener-los-demás-bloques>Obtener los demás bloques</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>Padding Oracle Attack a CBC</h1><p class=lead></p><p>Los ataques de tipo <em>Padding Oracle</em> se aprovechan de la estructura de mensajes cifrados en esquemas que utilizan <em>padding</em> para obtener el texto plano de un mensaje cifrado, realizando una cantidad de intentos considerablemente menor que los necesarios para obtenerlo mediante fuerza bruta y sin revelar la clave de cifrado.</p><p>El caso específico de <em>padding oracle attack</em> que veremos ahora aplica si se cumplen estas condiciones:</p><ul><li>Se usa criptografía simétrica, con cualquier tipo de cifrador de bloque y el modo de operación <em>CBC</em>.</li><li>El bloque utiliza algún tipo de <em>padding</em> predecible, como por ejemplo, <a href=https://tools.ietf.org/html/rfc5652#section-6.3><code>PKCS#7</code></a>.</li><li>El servicio que recibe el mensaje cifrado no tiene forma de autentificarlo, ya que de lo contrario, se podrían detectar las modificaciones al texto cifrado.</li><li>El servicio que recibe el mensaje cifrado entrega feedback de algún tipo, como un mensaje de error, cuando el padding está mal formado.</li></ul><h2 id=el-modo-cbc>El modo CBC<a href=#el-modo-cbc class=anchor aria-hidden=true>#</a></h2><p>Antes de hablar del ataque, conviene recordar cómo funciona el cifrado y descifrado al usar el modo de operación <em>CBC</em>.</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/CBC_encryption.svg/902px-CBC_encryption.svg.png alt="Cifrar en modo CBC"></p><p>La imagen anterior muestra que para un bloque \(B_i\), \(C(B_i) = BlockCipher(B_i \oplus C(B_{i-1}))\) (Asumiendo \(B_0 = IV\) y contando los bloques de texto plano a partir del 1).</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/CBC_decryption.svg/902px-CBC_decryption.svg.png alt="Descifrar en modo CBC"></p><p>Por otro lado, el proceso inverso muestra que para un bloque cifrado \(C_i\), \(D(C_i) = BlockDecipher(C_i) \oplus C_{i-1}) = B_i\). Le llamaremos \(I_i\) al estado intermedio del bloque descifrado antes de reaizar el \(\oplus\), por lo que la relación se puede escribir como \(B_i = I_i \oplus C_{i-1}\). Una propiedad interesante de \(I_i\) con respecto a \(B_i\) es que cada byte de \(C_{i-1}\) afecta de forma directa al byte en la misma posición de \(I_i\).</p><p><img src=./CBC_intermediate.svg alt="Estados intermedios"></p><h2 id=padding-pkcs7>Padding PKCS#7<a href=#padding-pkcs7 class=anchor aria-hidden=true>#</a></h2><p>El <em>padding</em> <em>PKCS#7</em> consiste en agregar entre 1 y \(BlockSize\) bytes al final de un mensaje, de tal forma que el valor de todos estos bytes debe ser igual a el número de bytes que le faltan al mensaje para completar el bloque. En caso que el tamaño del mensaje sea múltiplo del tamaño del bloque, se agrega al mensaje un bloque extra en el que todos los bytes tienen valor igual a \(BlockSize\).</p><p>Por ejemplo, si el mensaje a paddear es <code>Hola mundo</code> y el \(BlockSize\) es 16, el mensaje con <em>padding</em> es <code>Hola mundo[0x06][0x06][0x06][0x06][0x06][0x06]</code> (Los valores entre corchetes representan a un byte con ese valor hexadecimal). Mientras que si el mensaje a paddear es <code>Mensaje Completo</code> (largo 16) y el \(BlockSize\) es 16 bytes, el mismo mensaje con <em>padding</em> sería <code>Mensaje Completo[0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10][0x10]</code> (<code>0x10</code> es 16 en hexadecimal). Como se observa, este método de padding tiene sentido para bloques de tamaño de hasta 256 bytes.</p><p>Antes de cifrar un mensaje, se calcula y anexa el padding correspondiente. Luego, es el texto con padding el que se cifra. En el caso del proceso de descifrado, primero se descifra el mensaje usando el procedimiento habitual, y antes de entregarlo descifrado, se revisa su último byte y se remueven tantos bytes como la cantidad indicada por este valor.</p><h2 id=el-ataque>El ataque<a href=#el-ataque class=anchor aria-hidden=true>#</a></h2><p>Un detalle importante que conviene notar de la imagen que muestra los estados intermedios es que el texto descifrado del último bloque depende solamente del bloque intermedio (desconocido para nosotros, ya que no tenemos la llave del cifrador de bloque) y del bloque cifrado anterior (dato conocido, porque manejamos el texto cifrado). Por lo tanto, lo que haremos será crear una estrategia para poder encontrar el valor de los bloques intermedios, ya que con esa información podremos descifrar el mensaje sin necesidad de conocer la llave.</p><p>Si volvemos a revisar esta misma imagen, podremos notar notar que podríamos obtener el estado intermedio del bloque si manejáramos el texto plano y el valor del bloque cifrado anteriormente. Esto puede sonar un poco como un problema circular (dado que son dos los valores que no conocemos, el texto plano y el bloque intermedio), sin embargo, la estructura del modo CBC nos permite modificar el texto cifrado para que al descifrarse resulte en un texto plano distinto de forma controlada.</p><p>Lo anterior es posible dado que el texto descifrado depende del bloque anterior y el bloque intermedio final, si quisiéramos cambiar el valor del texto descifrado final, bastaría con cambiar el valor del bloque cifrado anterior. Este cambio al bloque cifrado anterior nos impediría descifrar de forma correcta ese bloque (ya que un pequeño cambio en un bloque cifrado con cifrador de bloque genera un gran cambio en su resultado descifrado), pero al mismo tiempo afectaría de forma controlada al resultado del bloque siguiente (ya que es operado a través de <code>xor</code> con el resultado del bloque intermedio), lo que repercute también en un cambio en el texto plano a descifrar.</p><p>Por lo tanto, podemos aprovechar la información que nos entrega el servidor (cuándo el padding del mensaje recibido es correcto y cuando no) para modificar el último byte del mensaje descifrado de forma tal que termine con el padding <code>0x01</code> a través de modificar el último byte del texto cifrado del bloque anterior hasta que el mensaje completo pase por padding. Si hacemos esto, podemos determinar el valor del bloque intermedio haciendo <code>xor</code> entre el byte modificado y <code>0x01</code>.</p><p>El valor del byte final del bloque intermedio encontrado sería exactamente el mismo que antes de modificar el último byte del bloque anterior, debido a que el bloque intermedio final depende solamente del cifrador de bloque, la llave usada y el bloque cifrado, el cual no hemos modificado. Ahora que tenemos el último byte del bloque intermedio, solamente necesitamos hacer <code>xor</code> entre él y el último byte original del bloque anterior para obtener el último byte en texto plano del texto cifrado original. ¡Esto nos requirió solamente 256 intentos!</p><p>En el caso de otros bytes en el último bloque, podemos usar la información manejada hasta ahora para ajustar el padding a otros valores, de tal forma que el primer byte de padding de izquierda a derecha sea el byte que estamos buscando, ya que cuando encontremos el valor que lo deja como padding correcto, podremos repetir el experimento anterior de forma de determinar el valor descifrado de esa parte del texto.</p><h2 id=el-algoritmo>El algoritmo<a href=#el-algoritmo class=anchor aria-hidden=true>#</a></h2><p>Ahora veremos la implementación del ataque anterior, dividiéndola en 3 fases. Primero intentaremos conseguir solamente el valor en texto plano del último byte cifrado del mensaje. Posteriormente, repetiremos este ataque para obtener todo el último bloque. Finalmente, veremos cómo obtener los demás bloques.</p><h3 id=obtener-el-último-byte-de-un-mensaje>Obtener el último byte de un mensaje<a href=#obtener-el-último-byte-de-un-mensaje class=anchor aria-hidden=true>#</a></h3><p>En esta fase, el ataque consiste en abusar del padding final de un mensaje encriptado simétricamente y del feedback que nos entrega la aplicación al recibir un mensaje mal cifrado.</p><p>En esta parte usaremos la notación \(B_i[j]\) para hablar del j-ésimo byte del bloque de texto plano número i. Los bloques irán numerados de \(0\) (el IV) a \(n\) (el último bloque del mensaje), mientras que los bytes en un bloque irán numerados de \(0\) a \(BlockSize-1\).</p><p>Podemos realizar la primera parte del ataque usando \(C_n[BlockSize-1]\) y (\(C_{n-1}[BlockSize-1]\)) (últimos bytes de los dos últimos bloques cifrados). Con esta información, intentaremos determinar el estado intermedio de (\(I_n[BlockSize-1]\)) a partir de generar un mensaje \(D_n\) cuyo texto plano tenga padding de <code>[0x01]</code> (es decir, \(D_n[BlockSize-1] = [0x01]\)), ya que este estado al validarse no generaría error de validación de padding y solamente depende del valor de 1 byte de padding. Recordemos que \(D_n[BlockSize-1]\) depende tanto de \(I_n[BlockSize-1]\) (no lo podemos tocar) como de \(C_{n-1}[BlockSize-1]\) (lo conocemos y podemos modificar), por lo que podemos ir iterando entre **los 256 posibles valores** de \(C_{n-1}[BlockSize-1]\) (al bloque modificado lo llamaremos \(M_{n-1}\)) hasta llegar a un \(M_{n-1}\) que haga que \(D_n[BlockSize-1]\).ea igual a <code>[0x01]</code>.</p><p>Sin embargo, existe la remota posibilidad de conseguir un resultado en el que el texto cifrado valida, pero su último byte en texto plano no es <code>[0x01]</code>. Esto puede ocurrir solamente si el penúltimo byte del último bloque es igual a <code>[0x02]</code>. ya que en este caso, el mensaje con padding validaría si el último byte también es <code>[0x02]</code>. Para descartar este caso, podemos modificar el valor del penúltimo byte de \(M_{n-1}\) por uno distinto al usado anteriormente. Si el mensaje sigue validando, significa que transformamos el último byte en <code>[0x01]</code>.</p><p>¿Qué hacemos con esta información? Conociendo \(M_{n-1}[BlockSize-1]\) y \(D_n[BlockSize-1]\) (<code>[0x01]</code>), podemos calcular \(I_n[BlockSize-1]\) haciendo \(\oplus\) entre ambos valores (Revisar gráfico de descifrado CBC para entender por qué es así). Además, como \(I_n[BlockSize-1]\) depende solamente de \(C_n[BlockSize-1]\) y no hemos modificado \(C_n\) en todo el proceso, estamos seguros que es el mismo valor que el obtenido antes de modificar \(C_{n-1}\).</p><p>Finalmente, para obtener \(B_n[BlockSize-1]\). basta con ejecutar el algoritmo de descifrado regular de CBC, es decir, hacer \(\oplus\) entre \(I_n[BlockSize-1]\) (valor obtenido recién) y \(C_{n-1}[BlockSize-1]\) (último bloque del mensaje original). Con esto, pudimos descubrir 1 byte del texto cifrado en solo 256 intentos. Si mantenemos esta eficiencia para los otros caracteres, podemos encontrar el texto plano sin conocer la llave en tiempo lineal.</p><p>En resumen, el algoritmo se podría describir de la forma siguiente:</p><ul><li>Copiar \(C_{n-1}\) a una nueva variable llamada \(M_{n-1}\). y cambiar \(M_{n-1}[BlockSize-1]\) a <code>[0x00]</code>.</li><li>Enviar mensaje cifrado modificado a validar. (Esto es, el mismo mensaje que antes, pero cambiando \(C_{n-1}\) por \(M_{n-1}\)).</li><li>Mientras mensaje no valide (\(D_n[BlockSize-1] !=\) <code>[0x01]</code>), aumentar \(M_{n-1}[BlockSize-1]\) en 1.</li><li>En el momento en que valide, significa que creamos un bloque \(D_n\) con padding correcto (casi seguramente su texto plano termina en <code>[0x01]</code>, pero podemos asegurarnos de aquello si repetimos el proceso cambiando \(M_{n-1}[BlockSize-2]\) por otro valor y la validación sigue pasando. Recuerda devolver el valor del byte luego de cambiarlo).</li><li>Hacemos \(\oplus\) entre el valor \(M_{n-1}[BlockSize-1]\) obtenido en el paso pasado y <code>[0x01]</code> (El texto plano que adivinamos), lo que nos entregará \(I_n[BlockSize-1]\)</li><li>Hacemos \(\oplus\) entre \(C_{n-1}[BlockSize-1]\) y \(I_n[BlockSize-1]\). Esto nos entregará \(B_n[BlockSize-1]\).</li></ul><h3 id=obtener-el-último-bloque-completo>Obtener el último bloque completo<a href=#obtener-el-último-bloque-completo class=anchor aria-hidden=true>#</a></h3><p>Hablemos en específico de la obtención del penúltimo byte antes de explicar el caso genérico. Conociendo el último byte del mensaje, podemos usar esta información para saber cómo modificar \(C_{n-1}[BlockSize-1]\). de forma que el valor de \(D_n[BlockSize-1]\) sea <code>[0x02]</code>. Esto se hace cambiando nuevamente el bloque \(C_{n-1}\) original por un bloque \(M_{n-1}\), y asignando a \(M_{n-1}[BlockSize-1]\) el valor de \(I_{n}[BlockSize-1] \oplus\) <code>0x02</code>, es decir, el valor intermedio del byte obtenido en el paso anterior operado con el valor del nuevo padding. El último término anulará el byte original (dejándolo en <code>[0x00]</code>) y el del medio lo dejará tal cual como queremos.</p><p>Ahora, repetimos los pasos de la sección anterior sobre el penúltimo byte, buscando eso sí un padding de <code>[0x02]</code>. Esto se puede generalizar para todos los bytes del bloque, cambiando el padding en cada ocasión por el correspondiente.</p><p>En otras palabras, este sería el algoritmo genérico para cualquier byte del último bloque:</p><ul><li>Si queremos descifrar el byte \(i\) del último bloque, y asumiendo que conocemos todos los bytes en \(B_{n}[i+1:BlockSize]\), para cada \(j \in [i+1,BlockSize)\) asignamos \(M_{n-1}[j] = I_{n-1}[j] \oplus PaddingByte\), donde \(PaddingByte = BlockSize - i\). Esto hará que los últimos bytes del mensaje de texto plano correspondan a un padding correcto cuando encontremos el valor del bloque número \(i\).</li><li>Ejecutamos la misma estrategia que para obtener el último byte, pero ahora asumiendo que si la validación pasa, el valor descifrado en este caso será igual a \(PaddingByte\). Es recomendable hacer la misma revisión que en el caso anterior para descartar paddings correctos debido a los datos del mensaje. (Cambiar el byte (i-1)-ésimo de \(M_{n-1}\) y verificar si sigue pasando la validación.)</li></ul><h3 id=obtener-los-demás-bloques>Obtener los demás bloques<a href=#obtener-los-demás-bloques class=anchor aria-hidden=true>#</a></h3><p>Dado que el valor de un bloque encriptado en modo CBC depende solamente de los bloques anteriores, podemos truncar del mensaje todos los bloques que ya conocemos, de forma de que el bloque desconocido más lejano del inicio del mensaje tome el rol de último bloque. Luego, se repiten los mismos pasos de las secciones anteriores. Es importante recordar que el bloque \(B_0\) corresponderá al vector de inicialización usado.</p><p>Es más, si facilita la implementación del ataque, en algunos casos es posible enviar solamente 2 bloques al oráculo a la vez (el anterior o el IV, y el que queremos descifrar).</p><p class=edit-page><a href=https://github.com/cc5327/apunte/blob/main/content/auxiliares/anexos/padding-oracle.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Editar en GitHub</a>
<span class=date-info><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Modificado por última vez el 19/04/2022 a las 22:55:06 hrs.</span></p><div class="docs-navigation d-flex justify-content-between"><a href=/auxiliares/enunciados/auxiliar-1/><div class="card my-1"><div class="card-body py-2">&larr; Auxiliar 1</div></div></a><a class=ml-auto href=/auxiliares/anexos/python-bytes/><div class="card my-1"><div class="card-body py-2">Strings y Bytes en Python 3 &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Sitio generado con <a href=https://gohugo.io/>Hugo</a> y <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-right"><ul class=list-inline><a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></ul></div></div></div></footer><script src=/main.2507c05f91ee016250e43b67b3d342f5a0d9d4dc5264f76cdc4518cd36a9e04cf3022ce8362802e618d8130b6733b53ee845a49e67229eeb3d3e70347db96a2b.js integrity="sha512-JQfAX5HuAWJQ5Dtns9NC9aDZ1NxSZPds3EUYzTap4EzzAizoNigC5hjYEwtnM7U+6EWknmcinus9PnA0fblqKw==" crossorigin=anonymous defer></script><script src=/index.min.95c2fb57984ca6cb1914e6658c1095cc47073a398c805d5ee842114fab739d64b4d5cd0626cda1be56c95e7f8c6e9c4d231866d1065245c873d731a6a7b01c5e.js integrity="sha512-lcL7V5hMpssZFOZljBCVzEcHOjmMgF1e6EIRT6tznWS01c0GJs2hvlbJXn+MbpxNIxhm0QZSRchz1zGmp7AcXg==" crossorigin=anonymous defer></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>