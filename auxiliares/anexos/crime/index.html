<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.034d9cba9deb1f52db75fa0931ca0fc2bba85beb0b9acc665c7d9736bb78dd22a4631f6e5e1f60c880c640e8a2fa42a2ef762e82830c85f9e4a30d8d52c2a6e9.css integrity="sha512-A02cup3rH1LbdfoJMcoPwruoW+sLmsxmXH2XNrt43SKkYx9uXh9gyIDGQOii+kKi73YugoMMhfnkow2NUsKm6Q==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>CRIME Attack - Introducción a la Seguridad Computacional</title><meta name=description content="DCC universidad de Chile"><link rel=canonical href=/auxiliares/anexos/crime/><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo_redondo.png"><meta name=twitter:title content="CRIME Attack"><meta name=twitter:description content="CRIME (Compression Ratio Info-leak Made Easy) es una vulnerabilidad encontrada el año 2012, la que ocurre al utilizar cifrado y compresión al mismo tiempo y que permite exfiltrar información sin conocer la llave de cifrado.
La hipótesis de su existencia fue levantada por Adam Langley, y fue demostrada por los investigadores Juliano Rizzo y Thai Duong (los mismos de la vulnerabilidad BREACH).
Contexto del problema Supuestos:
 El atacante puede ver el tráfico en el canal de comunicación."><meta name=twitter:site content="@dccuchile"><meta name=twitter:creator content="@dccuchile"><meta property="og:title" content="CRIME Attack"><meta property="og:description" content="CRIME (Compression Ratio Info-leak Made Easy) es una vulnerabilidad encontrada el año 2012, la que ocurre al utilizar cifrado y compresión al mismo tiempo y que permite exfiltrar información sin conocer la llave de cifrado.
La hipótesis de su existencia fue levantada por Adam Langley, y fue demostrada por los investigadores Juliano Rizzo y Thai Duong (los mismos de la vulnerabilidad BREACH).
Contexto del problema Supuestos:
 El atacante puede ver el tráfico en el canal de comunicación."><meta property="og:type" content="article"><meta property="og:url" content="/auxiliares/anexos/crime/"><meta property="og:image" content="/logo_redondo.png"><meta property="article:published_time" content="2022-03-24T10:00:00-03:00"><meta property="article:modified_time" content="2022-04-22T13:45:21-04:00"><meta property="og:site_name" content="Introducción a la Seguridad Computacional"><meta property="article:publisher" content="https://www.facebook.com/DCCUChile"><meta property="article:author" content="https://www.facebook.com/DCCUChile"><meta property="og:locale" content="es_CL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"\/"},{"@type":"ListItem","position":2,"name":"Auxiliaresanexoscrime","item":"\/auxiliaresanexoscrime\/"}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="auxiliares single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 mr-auto" href=/><img class=logo-light src=/images/banner.svg></img>
<img class=logo-dark src=/images/banner_dark.svg></img></a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/cc5327/apunte><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ml-2 sr-only">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=/acerca>Info</a></li><li class=nav-item><a class=nav-link href=/auxiliares/enunciados/auxiliar-1>Auxiliares</a></li><li class=nav-item><a class=nav-link href=/tareas/>Tareas</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Buscar Documentación..." aria-label="Buscar Documentación..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><div class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>anexos</h3><ul class=list-unstyled><li><a class=docs-link href=/auxiliares/anexos/servidor-cliente/>Cliente y Servidor Eco</a></li><li><a class="docs-link active" href=/auxiliares/anexos/crime/>CRIME Attack</a></li><li><a class=docs-link href=/auxiliares/anexos/padding-oracle/>Padding Oracle Attack a CBC</a></li><li><a class=docs-link href=/auxiliares/anexos/python-bytes/>Strings y Bytes en Python 3</a></li><li><a class=docs-link href=/auxiliares/anexos/gdb/>Uso básico de GDB</a></li></ul><h3>enunciados</h3><ul class=list-unstyled><li><a class=docs-link href=/auxiliares/enunciados/auxiliar-1/>Auxiliar 1</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>Contenidos</h3><nav id=TableOfContents><ul><li><a href=#contexto-del-problema>Contexto del problema</a></li><li><a href=#compresión--cifrado>Compresión + Cifrado</a></li><li><a href=#implementación>Implementación</a></li><li><a href=#cifradores-de-bloque-y-compresión>Cifradores de Bloque y compresión</a></li><li><a href=#referencias-y-más-información>Referencias y más información</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>CRIME Attack</h1><p class=lead></p><p>CRIME (<em>Compression Ratio Info-leak Made Easy</em>) es una vulnerabilidad encontrada el año 2012, la que ocurre al utilizar cifrado y compresión al mismo tiempo y que permite exfiltrar información sin conocer la llave de cifrado.</p><p>La hipótesis de su existencia fue levantada por Adam Langley, y fue <a href=https://docs.google.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU>demostrada</a> por los investigadores Juliano Rizzo y Thai Duong (los mismos de la vulnerabilidad BREACH).</p><h2 id=contexto-del-problema>Contexto del problema<a href=#contexto-del-problema class=anchor aria-hidden=true>#</a></h2><p><strong>Supuestos</strong>:</p><ul><li>El atacante puede ver el tráfico en el canal de comunicación.</li><li>Los datos viajan cifrados entre servidor y víctima, pero son comprimidos antes de cifrarse.</li><li>Atacante puede obligar a víctima a cargar rutas específicas del sitio a atacar.</li></ul><p>En otras palabras, aparte de ver (aunque cifrado) el tráfico entre la víctima y el servidor, el atacante tiene la posibilidad de gatillar consultas arbitrarias al servidor de parte del cliente del cual se quieren exfiltrar las cookies del usuario.</p><p>Esto podría realizarse en un sitio con contenido controlado por el atacante (por ejemplo, un blog con imágenes agregadas por el atacante) o con una vulnerabilidad web como <em>Cross Site Scripting</em> (La veremos más adelante en el curso).</p><p><strong>Objetivo</strong>: El atacante quiere robarse una cookie u otro valor importante que viaja en una consulta cifrada al servidor.</p><h2 id=compresión--cifrado>Compresión + Cifrado<a href=#compresión--cifrado class=anchor aria-hidden=true>#</a></h2><p>La gracia de cifrar datos es que no podemos saber nada de lo que éstos representan en texto plano.</p><p>Bueno, casi nada. En general podemos conocer más o menos el largo. (Más o menos porque el texto suele tener padding en algunos modos de cifrado)</p><p>Por otro lado, los algoritmos de compresión sin pérdida sí nos permiten obtener algo de información de un dato parcialmente desconocido, siempre que posea una componente de texto elegida por el atacante. A esto se le suele llamar <em>Oráculo de Compresión</em>.</p><p>No entraremos mucho en detalle de cómo funciona GZIP, pero en el pie de este anexo pueden encontrar detalles si desean entenderlo.</p><p>El tamaño del texto comprimido al cifrarse no varía (mucho), por lo que el cifrado <strong>no afecta (mucho) al rendimiento de un oráculo de compresión</strong>.</p><h2 id=implementación>Implementación<a href=#implementación class=anchor aria-hidden=true>#</a></h2><p>En esta implementación, asumimos que hay texto desconocido antes y después del texto que podemos enviar de entrada, y que, dentro del texto desconocido, hay tanto una parte conocida (<code>KNOWN</code>) como una parte desconocida inmediatamente después de lo conocido (<code>SECRET</code>).</p><p>A continuación mostramos una implementación recursiva y genérica de cómo usar la información entregada por un algoritmo de compresión para detectar el texto comprimido.</p><p><code>Función COMPRESSION_ORACLE(DATA)</code></p><ol><li>Dado un bytearray o string <code>X</code>, tenemos como <code>GZIP(X)</code> la versión comprimida de <code>X</code>, como <code>L(X)</code> la longitud de <code>X</code> y como <code>ENCRYPT(X)</code> la versión comprimida (AES-CBC con Key e IV definidos pero no explícitos) de <code>X</code>.</li><li>Retorna <code>L(ENCRYPT(GZIP(UNKNOWN_START + DATA + UNKNOWN_END)))</code>, donde <code>UNKNOWN_START</code> y <code>UNKNOWN_END</code> son valores desconocidos.</li></ol><p><code>Función ALGORITHM(KNOWN)</code></p><ol><li>Sean <code>W</code> el alfabeto de posibles caracteres en el secreto que queremos encontrar y <code>KNOWN</code> una pequeña parte conocida del texto, que no controlamos y que es adyacente al secreto que queremos encontrar.</li><li>Definimos <code>POSSIBLE</code> como un arreglo vacío con todas las respuestas posibles.</li><li>Definimos <code>UNCOMPRESSED_LENGTH</code> como <code>L(COMPRESS_ORACLE(KNOWN + y))</code>, con <code>y</code> un conjunto de varios (¿5 a 10?) caracteres fuera de <code>W</code></li><li>Definimos <code>NO_W</code> como un conjunto de entre 5 y 10 caracteres no pertenecientes a <code>W</code>.</li><li>Para cada caracter <code>c</code> en <code>W</code>:<ol><li>Definimos <code>BASE_LENGTH = COMPRESS_ORACLE(KNOWN + NO_W + c)</code></li><li>Definimos <code>C_LENGTH = COMPRESS_ORACLE(KNOWN + c + NO_W)</code></li><li>Si <code>C_LENGTH &lt; BASE_LENGTH</code>, agregamos <code>c</code> a la lista <code>POSSIBLE</code>.</li></ol></li><li>Definimos <code>RESPONSES</code> como una lista vacía</li><li>Si <code>POSSIBLE</code> no está vacío, para cada caracter <code>p</code> en <code>POSSIBLE</code>, <code>RESPONSES += ALGORITHM(KNOWN + C)</code></li><li>Devolver <code>RESPONSES</code></li></ol><p><code>RESPONSES</code> contendrá todas las posibles soluciones para <code>SECRET</code> justo después de <code>KNOWN</code>.</p><p>Notar que para que el algoritmo pueda partir adecuadamente, la primera invocación de <code>ALGORITHM</code> debe no ser vacía (y ojalá lo más larga posible).</p><p><strong>¿Para qué definimos <code>NO_W</code>?</strong> Para evitar que haya más compresión de la que esperamos. Dado que son caracteres no encontrados en <code>W</code>, estos no serán comprimidos de formas que no podamos predecir.</p><h2 id=cifradores-de-bloque-y-compresión>Cifradores de Bloque y compresión<a href=#cifradores-de-bloque-y-compresión class=anchor aria-hidden=true>#</a></h2><p>El algoritmo anterior no nos sirve tal cual con cifradores de bloque, dado que el largo del texto cifrado no es directamente proporcional al largo del texto plano, debido a la necesidad de agregar <em>padding</em> al texto.</p><p>El caso ideal sería que <code>BASE_LENGTH</code> generara un texto comprimido con padding de exactamente 1 bloque (16 bytes). De esta forma, cuando comprimamos el texto con un <code>c</code> candidato, el padding bajará a 1 byte, reduciéndose el número de bloques en 1.</p><p>Si seguimos extendiendo el texto, el tamaño comprimido debiese ser el mismo, por lo que el primer padding adecuado que calculemos servirá de ahí hasta exfiltrar completamente el secreto.</p><p>Entonces, lo que haremos es agregar antes de <code>KNOWN</code> (el texto inicial conocido) un texto compuesto de caracteres aleatorios (para evitar su compresión) denominado <code>BASURA</code>, cuyo largo es el adecuado para cumplir la condición de padding.</p><p><code>Función COMPUTE_PADDING(KNOWN):</code></p><ol><li>Calcular <code>BASE_LENGTH = COMPRESS_ORACLE(KNOWN)</code></li><li>Definir <code>NEW_LENGTH = BASE_LENGTH</code></li><li>Definir <code>BASURA = ''</code> (String vacío)</li><li>Mientras <code>NEW_LENGTH == BASE_LENGTH</code>:<ol><li>Redefinir <code>NEW_LENGTH = COMPRESS_ORACLE(BASURA + KNOWN)</code></li><li>Si <code>NEW_LENGTH &lt;= BASE_LENGTH</code>:<ol><li>Redefinir <code>BASURA += RANDOM(W)</code>, donde <code>RANDOM(Z)</code> obtiene un caracter aleatorio del alfabeto <code>Z</code></li></ol></li></ol></li><li>Devolver <code>BASURA[:-1]</code>, es decir, <code>BASURA</code> sin su último caracter (que es el texto cuyo largo el el máximo posible en el que el largo no aumenta)</li></ol><p>Luego, redefinir <code>KNOWN</code> como <code>BASURA + KNOWN</code> y usar el algoritmo original.</p><h2 id=referencias-y-más-información>Referencias y más información<a href=#referencias-y-más-información class=anchor aria-hidden=true>#</a></h2><ul><li><a href=https://zlib.net/feldspar.html>DEFLATE</a>, el algoritmo de compresión usado en GZIP, usa una combinación de <a href=https://archive.ph/20130107232302/http://oldwww.rasip.fer.hr/research/compress/algorithms/fund/lz/lz77.html>LZ77</a> y <a href=https://courses.cs.washington.edu/courses/cse143/10su/lectures/8-13/22-huffman.pdf>Huffman Coding</a></li><li><a href=https://github.com/mpgn/CRIME-poc/blob/master/CRIME-cbc-poc.py>CRIME-poc</a>: Implementación en Python. Muy parecida a lo que se busca en la tarea 2 y usada como base de esta explicación.</li><li><a href=https://security.stackexchange.com/questions/19911/crime-how-to-beat-the-beast-successor>Respuesta en StackOverflow</a> dada por alguien que no conocía la vulnerabilidad (todavía no eran públicos sus detalles), pero adivina sorprendentemente de qué trata. Es una muy buena explicación! pero en inglés.</li></ul><p class=edit-page><a href=https://github.com/cc5327/apunte/blob/main/content/auxiliares/anexos/crime.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Editar en GitHub</a>
<span class=date-info><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Modificado por última vez el 22/04/2022 a las 13:45:21 hrs.</span></p><div class="docs-navigation d-flex justify-content-between"><a href=/auxiliares/anexos/servidor-cliente/><div class="card my-1"><div class="card-body py-2">&larr; Cliente y Servidor Eco</div></div></a><a class=ml-auto href=/auxiliares/anexos/padding-oracle/><div class="card my-1"><div class="card-body py-2">Padding Oracle Attack a CBC &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Sitio generado con <a href=https://gohugo.io/>Hugo</a> y <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-right"><ul class=list-inline><a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></ul></div></div></div></footer><script src=/main.2507c05f91ee016250e43b67b3d342f5a0d9d4dc5264f76cdc4518cd36a9e04cf3022ce8362802e618d8130b6733b53ee845a49e67229eeb3d3e70347db96a2b.js integrity="sha512-JQfAX5HuAWJQ5Dtns9NC9aDZ1NxSZPds3EUYzTap4EzzAizoNigC5hjYEwtnM7U+6EWknmcinus9PnA0fblqKw==" crossorigin=anonymous defer></script><script src=/index.min.95c2fb57984ca6cb1914e6658c1095cc47073a398c805d5ee842114fab739d64b4d5cd0626cda1be56c95e7f8c6e9c4d231866d1065245c873d731a6a7b01c5e.js integrity="sha512-lcL7V5hMpssZFOZljBCVzEcHOjmMgF1e6EIRT6tznWS01c0GJs2hvlbJXn+MbpxNIxhm0QZSRchz1zGmp7AcXg==" crossorigin=anonymous defer></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>